% Generated by roxygen2 (4.1.0): do not edit by hand
% Please edit documentation in R/tmDriver.R
\name{tmDriver}
\alias{tmDriver}
\title{Runs simulations in batch mode.}
\usage{
tmDriver(funs, majors = 1, minors = 1, parallel = FALSE)
}
\arguments{
\item{funs}{A named list of generating functions, where the names correspond
  to \code{\link{tmRun}} argument names. Each function takes two integer
  parameters (major and minor run number) and returns an object appropriate
  for the particular argument (e.g. a generating function for the
  \code{'rain'}) argument would return a vector of annual rainfall values.

  Where a parameter value is constant over all simulations, an object can be
  provided directly for the corresponding \code{funs} list element (see
  example).}

\item{majors}{(integer) Either a single value for the number of major
  increments or a vector of values. If a single value, \code{M}, it will be
  treated as the sequence \code{1:M}.}

\item{minors}{(integer) Either a single value for the number of minor
  increments or a vector of values. If a single value, \code{m}, it will be
  treated as the sequence \code{1:m}.}

\item{parallel}{(logical) If TRUE, run the simulations in parallel using
  the \code{foreach} package. See example.}
}
\value{
A connection to a SQLite database containing the aggregated
  simulation outputs.
}
\description{
This function automates the process of generating parameter values, running
replicate simulations, and aggregating results into a single SQLite database.
The number of simulations to run is controlled by the \code{major} and
\code{minor} arguments (see Details).
}
\details{
The \code{funs} argument accepts a named list of parameter generators, where
the names indicate which \code{\link{tmRun}} argument the generator pertains
to. A generator can either be a function or an object to use as a constant
parameter value. Generating functions take two single integer values as
parameters, termed \emph{major} and \emph{minor}. Typically, \emph{major} is
used to index alternative parameter levels (e.g. overall average rainfall
value) while the minor index controls how many replicate simulations will be
run within each major level. However, an individual parameter generating
function is free to interpret these in any way, or ignore them completely.

If the \code{parallel} argument is \code{TRUE}, simulations will be run
concurrently using the \code{foreach} package. To use this option, you must
create and register a cluster prior to calling \code{tmDriver} and also
export any objects in the global environment which are referenced by
parameter generators. See the example code below.
}
\examples{
\dontrun{

# Combinations of average rainfall and annual fire probability
# in a data.frame in the global environment
param.combos <- expand.grid(
  rain.av = c(500, 700),
  fire.prob = c(0.1, 0.05, 0.025))

# Simulation length as a global var
SimLen <- 500

# This example also assumes that there is an object 'spp.params'
# in the global environment

# The list of parameter generators, with list element names
# corresonding to (abbreviated) tmRun argument names
funs <- list(
  # Constant object for Spp argument
  Spp = spp.params,

  # Function to generate initial cohort table.
  # Same behaviour over all simulations so the function
  # ignores major and minor arguments.
  #
  init = function(...) {
    Nspp <- length(spp.params)
    data.frame(sp = 1:Nspp,
               age = sample(20:50, Nspp),
               height = runif(Nspp, 5, 10),
               n = sample(1:20, Nspp) )
  },

  # Simple auto-correlated rainfall function where average
  # rainfall depends on major index
  #
  rain = function(maj, min) {
    avg <- param.combos[maj, "rain.av"]
    x <- stats::filter(rnorm(SimLen, avg, sd=100),
                       filter=rep(1, 3),
                       circular=TRUE)
    x / 3
  },

  # Scheduled fire where annual probability depends on
  # major index
  #
  scheduled.fire = function(maj, min) {
    p <- param.combos[maj, "fire.prob"]
    fires <- rbinom(SimLen, 1, p)

    # uniform fire intensity in this example
    fires[ fires > 0 ] <- 5

    fires
  }
)

# Run the simulations, with 100 replicates for each parameter
# combination
con <- tmDriver(funs, major = nrow(param.combos), minor = 100)

### Example of running the above in parallel (3 cores)

# Create a cluster and register it
library(doParallel)
cl <- makeCluster(3)
registerDoParallel(cl)

# Export objects required by the parameter generators in list 'funs'
clusterExport(cl, c("SimLen", "params", "param.combos"))

# Run the driver in parallel mode
con <- tmDriver(funs, major = nrow(param.combos), minor = 100, parallel = TRUE)

# Finish
stopCluster(cl)

}
}

